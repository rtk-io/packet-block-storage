#!/bin/bash
# Packet.net block storage auto-attach - dlaube

usage(){
  echo "usage: $0 [-vhm] [volume_name]"
  echo "	-v		Make verbose"
  echo "	-h		Display help"
  echo "	-m		Set multipath feature no_path_retry, ex: -m [<fail (default) | queue>]"
  echo "			If block storage is unreachable, the option "fail" results in FS read-only and "queue" will keep IO in memory buffer until reachable"
  echo "	volume_name	Specify the volume name to attach, eg: volume-f9a8a263"
  exit 1
}

# Get cli options
_V=0
while getopts "m:vh" OPTION
do
    case $OPTION in
        v) _V=1;;
        h) usage;;
	m) mpnpropt="$OPTARG";;
        *) exit 1;;
    esac
done

shift $(($OPTIND - 1))
if [ $1 ] ; then
	target=$1
fi

# Set multipath no_path_retry default if not set
if [[ -z "${mpnpropt}" ]]; then
	mpnpropt="fail"
fi
[ $_V -eq 1 ] && echo "Multipath no_path_retry feature option set as '$mpnpropt'"

# Depends on jq
if [ ! `which jq` ]; then
	echo "JQ was not found. Installing..."
	wget --quiet -O /bin/jq https://github.com/stedolan/jq/releases/download/jq-1.5/jq-linux64 && chmod +x /bin/jq
fi

# Check for deps
for dep in iscsiadm multipath jq;
do
	if type $dep &>/dev/null; then
		break
	else
		echo "Error: $dep not found. Please install it first."
		exit 1
	fi
done

# Check for multipath support
lsmod | grep dm_multipath &>/dev/null
if [ $? == 0 ]; then
  [ $_V -eq 1 ] && echo "Multipath module is loaded."
else
        [ $_V -eq 1 ] && echo "Multipath module not yet loaded. Restarting service."
        # Run multipath
        if [[ -f /usr/bin/systemctl && `systemctl` =~ -\.mount ]]; then
                [ $_V -eq 1 ] && echo "Restarting multipath with systemctl"
		modprobe dm_multipath
		modprobe dm_round_robin
                systemctl restart multipathd
                systemctl enable multipathd
        elif [[ -f /etc/init.d/multipath-tools && ! -h /etc/init.d/multipath-tools ]]; then
                [ $_V -eq 1 ] && echo "Restarting multipath with sysv init"
                /etc/init.d/multipath-tools restart &>/dev/null
        fi

        # Restart multipath with sysv init to fix ubuntu/deb
        if [[ -f /etc/init.d/multipath-tools && ! -h /etc/init.d/multipath-tools ]]; then
                [ $_V -eq 1 ] && echo "Restarting multipath with sysv init"
                /etc/init.d/multipath-tools restart &>/dev/null
        fi
fi

export LOCALMD=/tmp/metadata.tmp
curl -sSL https://metadata.packet.net/metadata > $LOCALMD
volumecnt=`jq '.volumes[].iqn' $LOCALMD | wc -l`
initiator=`jq '.iqn' $LOCALMD | sed 's/"//g'`

# Check for volumes
if [ $volumecnt -lt "1" ]; then
	echo "Error: No volume(s) associated with this server. Have you attached a volume to this server via the Packet.net API/Portal?"
	exit 1
fi

if [ "$target" ] ; then
	for (( idx=0; idx<$volumecnt; idx++ )) ; do
		volname=`jq '.volumes['$idx'].name ' $LOCALMD | sed 's/"//g'`
		if [ "$volname" = "$target" ] ; then
			targetidx=$idx
			continue
		fi
  done

  if [ "$targetidx" ] ; then
		echo "target has been set to: $target"
	else
		echo "target not found, is it connected to this host? : $target"
		exit 1
	fi
fi

function restart_iscsid {
        if [[ `which systemctl` && `systemctl` =~ -\.mount ]]; then
                [ $_V -eq 1 ] && echo "Restarting iscsid with systemctl"
                systemctl restart iscsid &>/dev/null
                if systemctl -q is-active open-iscsi; then
                        systemctl restart open-iscsi &>/dev/null
                fi
        elif [[ -f /etc/init.d/open-iscsi && ! -h /etc/init.d/open-iscsi ]]; then
                [ $_V -eq 1 ] && echo "Restarting iscsid with sysv init"
                /etc/init.d/open-iscsi restart &>/dev/null
        fi
}

# create the multipath config
cat <<- EOF_mpconf > /etc/multipath.conf
defaults {

       polling_interval       3
       fast_io_fail_tmo 5
       path_selector              "round-robin 0"
       rr_min_io                    100
       rr_weight                    priorities
       failback                    immediate
       no_path_retry              $mpnpropt
       user_friendly_names     yes

}

blacklist {
         devnode "^(ram|raw|loop|fd|md|dm-|sr|scd|st)[0-9]*"
         devnode "^hd[a-z][[0-9]*]"
         devnode "^vd[a-z]"
         devnode "^cciss!c[0-9]d[0-9]*[p[0-9]*]"

         device {
               vendor  "Micron"
               product ".*"
         }

         device {
               vendor  "Intel"
               product ".*"
         }

         device {
               vendor  "DELL"
               product ".*"
         }
}

devices {
        device {
                vendor "DATERA"
                product "IBLOCK"
                path_grouping_policy group_by_prio
                path_checker tur
                #checker_timer 5
                #prio_callout "/sbin/mpath_prio_alua /dev/%n"
                hardware_handler "1 alua"
        }
}
EOF_mpconf

# Initiator check
if [ ! `grep $initiator\$ /etc/iscsi/initiatorname.iscsi` ]; then
	[ $_V -eq 1 ] && echo "Initiator name mismatch! Updating from metadata..."
	echo "InitiatorName=$initiator" > /etc/iscsi/initiatorname.iscsi
	# Restart iscsid since it will have cached the previous initiator IQN
	[ $_V -eq 1 ] && echo "restarting iscsid"
	restart_iscsid
  multipath
fi

# iscsid config check - fix for Ubuntu/Debian since they default to manual
iscsiconf="/etc/iscsi/iscsid.conf"
if `grep -q 'node.startup = manual' "$iscsiconf"` || \
   `grep -q 'node.session.timeo.replacement_timeout = 120' "$iscsiconf"` || \
   `grep -q 'node.session.timeo.replacement_timeout = 15' "$iscsiconf"` || \
   `grep -q 'node.conn\[0\].timeo.noop_out_interval = 5' "$iscsiconf"` || \
   `grep -q 'node.conn\[0\].timeo.noop_out_timeout = 5' "$iscsiconf"`; then
		echo "updating iscsid.conf"
		sed -i.bak 's/node.startup = manual/node.startup = automatic/g' /etc/iscsi/iscsid.conf
		# Adjust timeout settings for decreased queue time during failover
		# Adjust for Ubuntu/Debian specific defaults
		sed -i.bak 's/node.session.timeo.replacement_timeout = 120/node.session.timeo.replacement_timeout = 5/g' /etc/iscsi/iscsid.conf
		# Adjust for RHEL/CentOS specific defaults
		sed -i.bak 's/node.session.timeo.replacement_timeout = 15/node.session.timeo.replacement_timeout = 5/g' /etc/iscsi/iscsid.conf
		sed -i.bak 's/node.conn\[0\].timeo.noop_out_interval = 5/node.conn\[0\].timeo.noop_out_interval = 3/g' /etc/iscsi/iscsid.conf
		sed -i.bak 's/node.conn\[0\].timeo.noop_out_timeout = 5/node.conn\[0\].timeo.noop_out_timeout = 3/g' /etc/iscsi/iscsid.conf
		# Restart iscsid since it will have old config values stored
		echo "restarting iscsid"
		restart_iscsid
		sleep 2
		multipath
fi

function attach_volume () {
  if [ -z "$1" ]
  then
    echo "Error: no volume index passed to attach_volume () function"
		exit
  fi

  [ $_V -eq 1 ] && echo "attaching volume index \"$1\"."
  volume="$1"

	iqn=`jq '.volumes['$volume'].iqn ' $LOCALMD | sed 's/"//g'`
	portals=`jq '.volumes['$volume'].ips ' $LOCALMD | egrep -o '([[:digit:]]{1,3}\.){3}[[:digit:]]{1,3}'`
	volname=`jq '.volumes['$volume'].name ' $LOCALMD | sed 's/"//g'`

	for portal in ${portals[@]}; do
		echo "portal: $portal iqn: $iqn"
		# Discover
		if iscsiadm --mode discovery --type sendtargets --portal $portal --discover &>/dev/null ; then
			[ $_V -eq 1 ] && echo "Discovery success on $portal"
		else
			echo "Error: We couldn't discover targets on $portal"
		fi

		# Login and attach
		if iscsiadm --mode node --targetname $iqn --portal $portal --login &>/dev/null ; then
			[ $_V -eq 1 ] && echo "Logged in iqn $iqn"

			sleep 3

			bdname=`ls -l /dev/disk/by-path/ | grep "$iqn" | grep $portal | awk {'print $11'} | sed 's/..\/..\///'`
			wwid=`/lib/udev/scsi_id -g -u -d /dev/$bdname`
			[ $_V -eq 1 ] && echo "Block device $bdname aka $volname is mapped to $iqn with WWID $wwid"

			[ $_V -eq 1 ] && echo "updating /etc/multipath/bindings with $volname $wwid"
			if `grep -q "^$volname" /etc/multipath/bindings`; then
				sed -i "s/^$volname .*/$volname $wwid/" /etc/multipath/bindings
			else
				echo "$volname $wwid" >> /etc/multipath/bindings
			fi

			multipath $volname
		else
			echo "Error: We couldn't log in iqn $iqn"
		fi
	done
}

if [ "$targetidx" ] ; then
	attach_volume $targetidx
else
	for (( idx=0; idx<$volumecnt; idx++ ))
	do
		attach_volume $idx
	done
fi

# cleanup mpath entries in bindings file
sed -i "/^mpath.*/d" /etc/multipath/bindings
if `ls /dev/mapper/mpath* >/dev/null 2>/dev/null`; then
  [ $_V -eq 1 ] && echo "mpath volume entries found, cleaning up"
  for i in `ls /dev/mapper/mpath* | cut -d / -f4`; do
    multipath -f $i
  done
  multipath
fi

mpresult=`multipath -ll`
[ $_V -eq 1 ] && echo "$mpresult"

# Check for block device(s)
for (( volume=0; volume<$volumecnt; volume++ )); do
	volname=`jq '.volumes['$volume'].name ' $LOCALMD | sed 's/"//g'`
	if [ -b /dev/mapper/$volname ]; then
		parted /dev/mapper/$volname mklabel msdos
		parted -a optimal /dev/mapper/$volname mkpart primary 0% 100%
		kpartx -u  /dev/mapper/$volname-part1
		mkfs -t ext3 /dev/mapper/$volname-part1
		mkdir -p /mnt/$volname-part1
		mount /dev/mapper/$volname-part1 /mnt/$volname-part1/
		echo "Block device /dev/mapper/$volname is available for use"
		echo "/mnt/$volname-part1"
	else
		echo "Error: Block device /dev/mapper/$volname is NOT available for use"
	fi
done
exit 0
